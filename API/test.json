{"ChildProcess":"function ChildProcess() {  FunctionPrototypeCall(EventEmitter, this);  this._closesNeeded = 1;  this._closesGot = 0;  this.connected = false;  this.signalCode = null;  this.exitCode = null;  this.killed = false;  this.spawnfile = null;  this._handle = new Process();  this._handle[owner_symbol] = this;  this._handle.onexit = (exitCode, signalCode) => {    if (signalCode) {      this.signalCode = signalCode;    } else {      this.exitCode = exitCode;    }    if (this.stdin) {      this.stdin.destroy();    }    this._handle.close();    this._handle = null;    if (exitCode < 0) {      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';      const err = errnoException(exitCode, syscall);      if (this.spawnfile)        err.path = this.spawnfile;      err.spawnargs = ArrayPrototypeSlice(this.spawnargs, 1);      this.emit('error', err);    } else {      this.emit('exit', this.exitCode, this.signalCode);    }    // If any of the stdio streams have not been touched,    // then pull all the data through so that it can get the    // eof and emit a 'close' event.    // Do it on nextTick so that the user has one last chance    // to consume the output, if for example they only want to    // start reading the data once the process exits.    process.nextTick(flushStdio, this);    maybeClose(this);  };}","_forkChild":"function _forkChild(fd, serializationMode) {  // set process.send()  const p = new Pipe(PipeConstants.IPC);  p.open(fd);  p.unref();  const control = setupChannel(process, p, serializationMode);  process.on('newListener', function onNewListener(name) {    if (name === 'message' || name === 'disconnect') control.refCounted();  });  process.on('removeListener', function onRemoveListener(name) {    if (name === 'message' || name === 'disconnect') control.unrefCounted();  });}","default":"[object Object]","exec":"function exec(command, options, callback) {  const opts = normalizeExecArgs(command, options, callback);  return module.exports.execFile(opts.file,                                 opts.options,                                 opts.callback);}","execFile":"function execFile(file, args = [], options, callback) {  if (args != null && typeof args === 'object' && !ArrayIsArray(args)) {    callback = options;    options = args;    args = null;  } else if (typeof args === 'function') {    callback = args;    options = null;    args = null;  }  if (typeof options === 'function') {    callback = options;    options = null;  } else if (options != null) {    validateObject(options, 'options');  }  if (callback != null) {    validateFunction(callback, 'callback');  }  options = {    encoding: 'utf8',    timeout: 0,    maxBuffer: MAX_BUFFER,    killSignal: 'SIGTERM',    cwd: null,    env: null,    shell: false,    ...options  };  // Validate the timeout, if present.  validateTimeout(options.timeout);  // Validate maxBuffer, if present.  validateMaxBuffer(options.maxBuffer);  options.killSignal = sanitizeKillSignal(options.killSignal);  const child = spawn(file, args, {    cwd: options.cwd,    env: options.env,    gid: options.gid,    shell: options.shell,    signal: options.signal,    uid: options.uid,    windowsHide: !!options.windowsHide,    windowsVerbatimArguments: !!options.windowsVerbatimArguments  });  let encoding;  const _stdout = [];  const _stderr = [];  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {    encoding = options.encoding;  } else {    encoding = null;  }  let stdoutLen = 0;  let stderrLen = 0;  let killed = false;  let exited = false;  let timeoutId;  let ex = null;  let cmd = file;  function exithandler(code, signal) {    if (exited) return;    exited = true;    if (timeoutId) {      clearTimeout(timeoutId);      timeoutId = null;    }    if (!callback) return;    // merge chunks    let stdout;    let stderr;    if (encoding ||      (        child.stdout &&        child.stdout.readableEncoding      )) {      stdout = ArrayPrototypeJoin(_stdout, '');    } else {      stdout = Buffer.concat(_stdout);    }    if (encoding ||      (        child.stderr &&        child.stderr.readableEncoding      )) {      stderr = ArrayPrototypeJoin(_stderr, '');    } else {      stderr = Buffer.concat(_stderr);    }    if (!ex && code === 0 && signal === null) {      callback(null, stdout, stderr);      return;    }    if (args?.length)      cmd += ` ${ArrayPrototypeJoin(args, ' ')}`;    if (!ex) {      ex = genericNodeError(`Command failed: ${cmd}\\n${stderr}`, {        code: code < 0 ? getSystemErrorName(code) : code,        killed: child.killed || killed,        signal: signal      });    }    ex.cmd = cmd;    callback(ex, stdout, stderr);  }  function errorhandler(e) {    ex = e;    if (child.stdout)      child.stdout.destroy();    if (child.stderr)      child.stderr.destroy();    exithandler();  }  function kill() {    if (child.stdout)      child.stdout.destroy();    if (child.stderr)      child.stderr.destroy();    killed = true;    try {      child.kill(options.killSignal);    } catch (e) {      ex = e;      exithandler();    }  }  if (options.timeout > 0) {    timeoutId = setTimeout(function delayedKill() {      kill();      timeoutId = null;    }, options.timeout);  }  if (child.stdout) {    if (encoding)      child.stdout.setEncoding(encoding);    child.stdout.on('data', function onChildStdout(chunk) {      const encoding = child.stdout.readableEncoding;      const length = encoding ?        Buffer.byteLength(chunk, encoding) :        chunk.length;      const slice = encoding ? StringPrototypeSlice :        (buf, ...args) => buf.slice(...args);      stdoutLen += length;      if (stdoutLen > options.maxBuffer) {        const truncatedLen = options.maxBuffer - (stdoutLen - length);        ArrayPrototypePush(_stdout, slice(chunk, 0, truncatedLen));        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');        kill();      } else {        ArrayPrototypePush(_stdout, chunk);      }    });  }  if (child.stderr) {    if (encoding)      child.stderr.setEncoding(encoding);    child.stderr.on('data', function onChildStderr(chunk) {      const encoding = child.stderr.readableEncoding;      const length = encoding ?        Buffer.byteLength(chunk, encoding) :        chunk.length;      stderrLen += length;      if (stderrLen > options.maxBuffer) {        const truncatedLen = options.maxBuffer - (stderrLen - length);        ArrayPrototypePush(_stderr,                           chunk.slice(0, truncatedLen));        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');        kill();      } else {        _stderr.push(chunk);      }    });  }  child.addListener('close', exithandler);  child.addListener('error', errorhandler);  return child;}","execFileSync":"function execFileSync(command, args, options) {  options = normalizeSpawnArguments(command, args, options);  const inheritStderr = !options.stdio;  const ret = spawnSync(options.file,                        ArrayPrototypeSlice(options.args, 1), options);  if (inheritStderr && ret.stderr)    process.stderr.write(ret.stderr);  const err = checkExecSyncError(ret, options.args, undefined);  if (err)    throw err;  return ret.stdout;}","execSync":"function execSync(command, options) {  const opts = normalizeExecArgs(command, options, null);  const inheritStderr = !opts.options.stdio;  const ret = spawnSync(opts.file, opts.options);  if (inheritStderr && ret.stderr)    process.stderr.write(ret.stderr);  const err = checkExecSyncError(ret, opts.args, command);  if (err)    throw err;  return ret.stdout;}","fork":"function fork(modulePath, args = [], options) {  modulePath = getValidatedPath(modulePath, 'modulePath');  // Get options and args arguments.  let execArgv;  if (args == null) {    args = [];  } else if (typeof args === 'object' && !ArrayIsArray(args)) {    options = args;    args = [];  } else {    validateArray(args, 'args');  }  if (options != null) {    validateObject(options, 'options');  }  options = { ...options, shell: false };  options.execPath = options.execPath || process.execPath;  // Prepare arguments for fork:  execArgv = options.execArgv || process.execArgv;  if (execArgv === process.execArgv && process._eval != null) {    const index = ArrayPrototypeLastIndexOf(execArgv, process._eval);    if (index > 0) {      // Remove the -e switch to avoid fork bombing ourselves.      execArgv = ArrayPrototypeSlice(execArgv);      ArrayPrototypeSplice(execArgv, index - 1, 2);    }  }  args = [...execArgv, modulePath, ...args];  if (typeof options.stdio === 'string') {    options.stdio = stdioStringToArray(options.stdio, 'ipc');  } else if (!ArrayIsArray(options.stdio)) {    // Use a separate fd=3 for the IPC channel. Inherit stdin, stdout,    // and stderr from the parent if silent isn't set.    options.stdio = stdioStringToArray(      options.silent ? 'pipe' : 'inherit',      'ipc');  } else if (!ArrayPrototypeIncludes(options.stdio, 'ipc')) {    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');  }  return spawn(options.execPath, args, options);}","spawn":"function spawn(file, args, options) {  options = normalizeSpawnArguments(file, args, options);  validateTimeout(options.timeout);  validateAbortSignal(options.signal, 'options.signal');  const killSignal = sanitizeKillSignal(options.killSignal);  const child = new ChildProcess();  debug('spawn', options);  child.spawn(options);  if (options.timeout > 0) {    let timeoutId = setTimeout(() => {      if (timeoutId) {        try {          child.kill(killSignal);        } catch (err) {          child.emit('error', err);        }        timeoutId = null;      }    }, options.timeout);    child.once('exit', () => {      if (timeoutId) {        clearTimeout(timeoutId);        timeoutId = null;      }    });  }  if (options.signal) {    const signal = options.signal;    if (signal.aborted) {      process.nextTick(onAbortListener);    } else {      signal.addEventListener('abort', onAbortListener, { once: true });      child.once('exit',                 () => signal.removeEventListener('abort', onAbortListener));    }    function onAbortListener() {      abortChildProcess(child, killSignal);    }  }  return child;}","spawnSync":"function spawnSync(file, args, options) {  options = {    maxBuffer: MAX_BUFFER,    ...normalizeSpawnArguments(file, args, options)  };  debug('spawnSync', options);  // Validate the timeout, if present.  validateTimeout(options.timeout);  // Validate maxBuffer, if present.  validateMaxBuffer(options.maxBuffer);  // Validate and translate the kill signal, if present.  options.killSignal = sanitizeKillSignal(options.killSignal);  options.stdio = getValidStdio(options.stdio || 'pipe', true).stdio;  if (options.input) {    const stdin = options.stdio[0] = { ...options.stdio[0] };    stdin.input = options.input;  }  // We may want to pass data in on any given fd, ensure it is a valid buffer  for (let i = 0; i < options.stdio.length; i++) {    const input = options.stdio[i] && options.stdio[i].input;    if (input != null) {      const pipe = options.stdio[i] = { ...options.stdio[i] };      if (isArrayBufferView(input)) {        pipe.input = input;      } else if (typeof input === 'string') {        pipe.input = Buffer.from(input, options.encoding);      } else {        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`,                                       ['Buffer',                                        'TypedArray',                                        'DataView',                                        'string'],                                       input);      }    }  }  return child_process.spawnSync(options);}"}